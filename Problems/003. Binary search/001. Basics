package com.beginnerdsa.step3._3_binary_search;
/*
binary search is mostly used when we see
--> sorted data,
-->data becomes sorted after some operations like rotating the elements, bitonic ,etc
-->when we see monotonic predicate / condition like one true then always true or once false then always false
eg- F F F F F F F F F T T T T T T T T T T,

-->even if the data is not sorted but the logic creates a sorted behaviour, eg- square root on N, nth root of N ,or increasing function or decreasing function.


 */


import java.util.Arrays;

/*
we need to find the first occurrence of T:

F F F F F F F F F F T  T  T  T  T  T  T
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

We will make 4 variables: l,r,mid, first occurrence
in starting:
l=0 , r=16 , mid=16/2=8, FO=-1
l and r means the range where we can find the target.
and we will check the mid-element for each time.

we get F at arr[mid] so we now know from 0 to mid we will not get desired element
because we have a monotonous pattern here if we get F then all the previous elements will surely by F
so,

we cut the left half of array,
now updated variables are
l=mid+1=9 (as the middle element is also not the desired one)
r=16
mid=9+16/2=12
fo=-1

we get T at arr[mid] , so we can tell now from 12 and afterward we can get all T and maybe some range
like 9 to 11 we may or may not have left some T's
so what we will do is
we will update the first occurrence of T in fo, as index 12.
and will surely know that from 13 to 16 all the T will not be our first occurrence because
we get our true at index 12 means before 13 to 16 so we discard these range
our updated variable become:
fo=12
l=9
r=mid-1=11 (as we now have to check before the mid index)
mid=9+11=10

we get T, so we update first occurrence as 10<12, so
fo=10,

now we know after 10, all the T we get will be not first occurrence, so we check
from
l=9
r=mid-1= 10-1=9
mid=9

so we get F, now we know all the left from it will be F and so we move to right
make l=mid+1 = 9+1=10
r= 9
mid=9

we get l>r so we stop and return the FO.


while(l<=r){
    if arr[mid]<k:
        l=mid+1;

    elseif arr[mid]>k:
        r=mid-1

    else return true;  (arr[mid]==k)

return false;
}

 */



/*
to find the first and last occurrence of target:

the main thing to remember is when to search left and when to search right:

for finding first occurrence,
if we found the element we try to search in left half.
if mid is > then search in left.
if mid is < then search in right.

for finding last occurrence,
if we found the element we try to search more in right half.
if mid is > then search in left.
if mid is < then search in right.


and for each iteration we update mid in starting only,
no need to update everytime in each if else loop
 */
public class _01_BS_basics {
    public static int firstocc(int[] nums, int target){
        int left=0;
        int right=nums.length-1;
        int firstoc=-1;

        while(left<=right){
            int mid= left+(right-left)/2;
            if(nums[mid]==target){
                firstoc=mid;
                right=mid-1;
            }
            else if(nums[mid]<target){
                left=mid+1;
            }
            else{
                right=mid-1;
            }
        }
        return firstoc;

    }
    public static int lastocc(int[] nums, int target){
        int left=0;
        int right=nums.length-1;
        int lastoc=-1;

        while(left<=right){
            int mid= left+(right-left)/2;
            if(nums[mid]==target){
                lastoc=mid;
                left=mid+1;
            }
            else if(nums[mid]<target){
                left=mid+1;
            }
            else{
                right=mid-1;
            }
        }
        return lastoc;

    }

    public static void main(String[] args) {
        int [] nums={5,7,7,8,8,10};
        int target=10;
        int[] arr={firstocc(nums,target),lastocc(nums,target)};
        System.out.println(Arrays.toString(arr));
    }
}



/*
Binary search is for ANY problem where:

1️⃣ The answer lies in a monotonic (sorted) range
2️⃣ You can ask: “Is this guess too big or too small?”

HOW TO KNOW IN FUTURE

Whenever you see a question like:
find a value x such that f(x) = target
and f(x) is monotonic
and x lies in a numerical range
and you can check mid easily
then,
Binary Search on Answer is the right method.


 */
