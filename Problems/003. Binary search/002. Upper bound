package com.beginnerdsa.step3._3_binary_search;
/*

we need to return the upper bound of target,
upper bound = element just greater then target.

we calculate mid then check if that is less than or equal to target
if yes then we shrink the left because now we know that our upper bound will be in right half now,

if no, then we should think if can we find more accurate upper bound to the left?
eg- if mid= 900 and target is 700, in arr= 200,500,700,800,900
so our upper bound should be 800 not 900, so we will confirm if arr[mid-1]> target
if yes then shrink the right
if not then return the mid because that is the answer.
(1 based indexing solves this naturally)

but what if we got an element > target at the index 0,
then we cannot do the condition to check if arr[mid-1]>target that will give error.
so we manage that too. but in 1 based indexing this condition is naturally solved.

eg- arr=4,5,6,7,8;  t=3;
this in 1 based indexing arr[mid-1] need not to be checked as it naturally handles it
and in 0 based indexing we can counter error like arr[mid-1] ==> arr[0-1] = arr[-1]
so we need to handle that because we had 0 based indexing


at last 1 more condition if we get all elements in array that are less than target so we return the left.
because when all the time arr[mid]<=target then we keep shrinking out left at last we reach to right most end.
and left becomes our answer. however 1 based indexing and 0 based indexing gives different result like:
in arr=1,3,5,7,9 and t=100
0 based will give 5 and 1 based indexing will give answer 6 but both are correct acc. to there indexing.


however we can do 1 based indexing logic in 0 based indexing also, like l=0 and r= arr.length while(l<r){} and inside conditions
 */


/*
public class _02_BS_upper_bound {
    public static int upperBound(int[] arr, int target) {
        int left = 0;
        int right = arr.length-1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] <= target) {
                left = mid + 1;
            }
            else {
                if (mid == 0) {
                    return 0;
                }
                else {
                    if (arr[mid - 1] > target) {
                        right = mid - 1;
                    }
                    else {
                        return mid;
                    }
                }
            }
        }
        return left;
    }


    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9};
        int target = 100;

        int answer = upperBound(arr, target);
        System.out.println(answer);

    }
}*/


//0 based indexing but naturally handling mid=0 and arr[mid-1] case:

public class _02_BS_upper_bound {
    public static int upperBound(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] <= target) {
                left = mid + 1;  // move past all <= target
            } else {
                right = mid - 1; // potential upper bound
            }
        }

        return left;  // first index where arr[i] > target
    }

    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9};
        int target = 100;

        int answer = upperBound(arr, target);
        System.out.println(answer);

    }
}
