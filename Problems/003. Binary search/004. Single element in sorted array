package com.beginnerdsa.step3._3_binary_search;
/*
we have some elements in an array, where all elements are present exactly twice
except 1, 1 number is present only once, we need to find that number index.


so for optimize, we will see
3,3,5,5,6,6,8,8,9,10,10,12,12,14,14
0 1 2 3 4 5 6 7 8 9  10 11 12 13 14
e,o,e,o,e,o,e,o,e,o, e, o, e, o ,e

so we can see a pattern where all the combos of 2 numbers before that target number
are forming e,o pattern and after coming of target all combos are making o,e pattern.

so at mid, we will check if index is odd and arr[mid]==arr[mid+1] then we shrink left becasue this pattern if found before target/
and if we are at odd index then we check if  arr[mid]==arr[mid-1] then we also shrink left as mid+1 as we know before target combo follows e,o pattern

so else, we make right=mid.
why not mid-1.
in example -> [3,3,5,6,6]
we see mid is at even index, so we check arr[mid]==arr[mid+1] ? no so we do r=mid-1, but here our answer will be lost.
so we do right=mid.


and why we did while(l<r) instead of while(l<=r)
because when l==r we are sure that we are on our target but if while(l<=r) then loop will execute once more, and we can have array out of bound error.
so we do while(l<r) and we sout l as we are sure after last executing l or r will point to target.


 */
public class _04_BS_single_element_in_sorted_array {
    public static void main(String[] args) {
        int[] arr={3,3,5,5,6,6,8,8,9,10,10,12,12,14,14};
        int l=0;
        int r=arr.length-1;
        while(l<r){
            int mid=l+(r-l)/2;

            if(mid%2!=0 && arr[mid]==arr[mid-1] || mid%2==0 && arr[mid]==arr[mid+1]){
                l=mid+1;
            }
            else{
                r=mid;
            }
        }
        System.out.println(l);
    }
}
