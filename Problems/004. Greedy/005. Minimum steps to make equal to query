package com.beginnerdsa.step3._4_Greedy;
/*
given an array price, where price of ith item is price[i],
given an array of query, we need to make each price item equal to that query one by one.
we can only increase or decrease the price by 1.
we need to find the minimum number of steps so that each price is converted into each query.

eg: price[]={1,2,3}
    query[]={2}

    so to make each price equal to query we need to:
    increase price[0] by 1, price[1] by 0
    decrease price[2] by 1.
    so total we need 2 operations.

so,
bruteforce:

we declare n (size of price array)
read price array
declare q (size of query array)
read query array
then,
for each query we iterate our price array and subtract abs(price[i]-query[j])

time complexity: O(n*q)



optimized:

eg:
price[N=4]={2,3,4,5}
if target=8
then: 8-2,8-3,8-4,8-5 = target*N - (sum of all elements of price array)

if target=1
then: 2-1,3-1,4-1,5-1 = (sum of all elements of price array) - target*N

so if the target is <elements of price then we use a specific formula otherwise another specific formula but.
what if we have a mix of elements in price.

eg: price={1,2,3,4,9,10,11,12}  query={5}

so first we will sort the array, then find sum of all elements less than or equal to 5.
then count the elements less than 5, then use that formula on them
and another formula or left over elements.

if we try to shrink the formula to a 1 formula,
we cannot use : abs(target*N - (sum of all elements))
this will not work
as if price=[5,10] target=9
answer: 4+1=5

answer through new formula: (9*2-(15))= 3
this is not correct, we need to handle elements larger than target and less than target separately.

so how will i know till when the elements are larger and till when elements are smaller than query.
by sorting them and using binary search we will find the exact index where all elements less than that are smaller and all elements greater than that are larger then query

and how we will store the sum of elements: through prefix sum.

//time complexity: O(q logn + n log n +n) for binary search, sorting array, calculating prefix sum.
*/

import java.util.Arrays;
import java.util.Scanner;

/*
public class _05_min_step_to_make_equal_to_query {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int q = sc.nextInt();
        int[] price=new int[n];
        int[] query=new int[q];
        int minoperation=0;

        for(int i=0;i<n;i++){
            price[i]=sc.nextInt();
        }
        for(int i=0;i<q;i++){
            query[i]=sc.nextInt();
        }
        for(int i=0;i<q;i++){
            minoperation=0;
            for(int j=0;j<n;j++){
                minoperation+=Math.abs(query[i]-price[j]);
            }
            System.out.println(minoperation);
        }
    }
}
*/





public class _05_min_step_to_make_equal_to_query {
    public static int upperBound(int[] arr,int t){
        int index=0;
        int l=0;
        int r=arr.length-1;
        while(l<=r){
            int mid=(l+r)/2;
            if(arr[mid]<=t){
                l=mid+1;
            }
            else{
                if(mid==0){
                    return arr[mid];
                }
                else{
                    if(arr[mid-1]>t){
                        r=mid-1;
                    }
                    else{
                        return mid;
                    }
                }
            }
        }
        return l;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int q = sc.nextInt();
        int[] price=new int[n];
        int[] query=new int[q];
        int[] prefixSum=new int[n+1];
        int minoperation=0;
        for(int i=0;i<n;i++){
            price[i]=sc.nextInt();
        }
        for(int i=0;i<q;i++){
            query[i]=sc.nextInt();
        }
        Arrays.sort(price);

        for(int i=1;i<=price.length;i++){
            prefixSum[i]=prefixSum[i-1]+price[i-1];
        }

        for(int i=0;i<q;i++){
            int index=upperBound(price,query[i]);
            int min1=query[i]*index-prefixSum[index];
            int min2=(prefixSum[n]-prefixSum[index])-(query[i]*(n-index));
            System.out.println(min1+min2);
        }
    }
}


